# 람다 표현식이란?

메서드로 전달할 수 있는 익명 함수를 단순화 한 것

이로 인해서 동작 파라미터를 사용할 때 익명 클래스 등 판에 박힌 코드를 구현할 필요가 없이,
람다 표현식을 사용하면 동작 파라미터 형식을 쉽게 구현할 수 있다.

# 어떻게 사용할까?

### 함수형 인터페이스

함수형 인터페이스는 정확히 하나의 추상 메서드를 지정하는 이너테이스이다.
예를 들어서 Comparator, Runnable 등이 존재한다.
하지만 추가적으로 디폴트 메서드를 추가해서 인터페이스의 확장성을 고려했지만, 많은 디폴트 메서드가 있다고 하더라도
추상메서드 가 하나라면 함수형 인터페이스(Functional Interface)이다.

### 그렇다면 함수형 이넡페이스로 뭘 하는데?

람다 표현식으로 함수형 인터페이스의 추상 메서드의 구현부를 직접 전달할 수 있다.
이를 통해서 전체 표현식을 함수형 인터페이스의 인스턴스로 취급할 수 있다.
즉, 기술적으로 따지면 함수형 인터페이스를 구현한 클래스의 인스턴스로 취급이 가능하다.

# 함수 디스크립터

함수형 인터페이스의 추상 메서드 시그니처(Signature)는 람다 표현식의 시그니처를 가리킨다.
람다표현식의 시그니처를 서술하는 메서드를 함수 디스크립터(Function Descriptor)라고 부른다.
예를 들어서 Runnable 인터페이스의 추상 메서드인 run()은 인수와 반환값이 없음(void를 반환)
따라서 Runnable 인터페이스는 인수와 반환값이 없는 시그니처로 생각할 수 있다.

일단 여기서는 람다 표현식은 변수에 할당하거나 함수형 인터페이스를 인수로 받는 메서드로 전달이 가능하며,
함수형 인터페이스의 추상 메서드와 같은 시그니처를 가져야 하는 것으로 기억하자.

# 실행 어라운드 패턴

자원 처리에 사용되는 순환 패턴은 자원을 열고, 처리한 다음에, 자원을 닫는 순서로 이루어진다.
즉, 실제 자원을 처리하는 코드를 설정과 정리 두 과정이 둘러싸는 형태가 실행 어라운드 패턴이다.

만일 코드에서 파일을 한 줄만 읽도록 코드를 짰다고 가정하고,
한 번에 두 줄을 읽거나 다른 작업을 수행하려면 기존의 설정과 정리 과정은 재사용하고 중간 처리 과정만
다른 동작을 수행하도록 명령 해야할 것이다.

즉, 동작 파라미터화 시켜야한다.

이를 하기 위한 과정은 다음과 같다.

1. 함수형 인터페이스를 통한 동작 전달
2. 동작 실행
3. 람다 전달

# 함수형 인터페이스 사용

함수형 인터페이스에는 하나의 추상 메서드가 있어야만 한다. 그래서 다양한 람다 표현식을 사용하려면
공통의 함수 디스크립터를 기술하는 함수형 인터페이스 집합이 필요하다.
따라서 자바 API는 Comparable, Runnable, Callable 등 다양한 함수형 인터페이스를 포함한다.

### Predicate

`java.util.function.Predicate<T>` 인터페이스는 형식 T 객체를 받아서 void를 반환하는 test라는 메서드를 정의한다.
T 형식의 객체를 사용하는 boolean 표현식이 필요한 상황에서 사용할 수 있다.

`java.util.function.Consumer<T>` 인터페이스는 형식 T 객체를 받아서 void를 반환하는 accept라는 메서드를 정의한다.
T 형식의 객체를 인수로 받아서 동작을 수행하고 싶을 때 사용할 수 있다.

`java.util.function.Function<T, R>` 인터페이스는 형식 T를 인수로 받아서 제네릭 형식 R 객체를 반환하는 추상 메서드 apply를 정의한다.
입력을 출력으로 매핑하는 람다를 정의할 때 Function 인터페이스를 사용할 수 있다.

자바의 모든 형식은 참조형에 해당한다. 하지만 제네릭 파라미터에는 참조형만 사용할 수 있다.
자바에서는 기본형을 참조형으로 변환할 수 있는 기능이 있는데 박싱이고,
참조형을 기본형으로 변환하는 동작이 언박싱이라고 한다.
또한 자동으로 박싱과 언박싱이 이루어지는 오토 박싱이 제공됨.

-> 하지만 이러한 변환은 비용이 소모됨. 박싱한 값은 기본형을 감싸는 래퍼며 힙에 저장된다.
따라서 박싱한 값은 메모리를 더 소모하며 기본형을 가져올 때도 메모리를 탐색하는 과정이 필요함.

자바 8에서는 오토박싱을 피할 수 있는 함수형 인터페이스가 제공된다.
일반적으로 특정 형식을 입력으로 받는 함수형 인터페이스 이름 앞에는 DoublePredicate 처럼 형식명이 붙음

# 형식 추론

1. filter 메서드 선언을 확인
2. filter 메서드는 두 번째 파라미터로 Predicate<Apple> 형식을 기대
3. Predicate<Apple> 은 test라는 한 개의 추상 메서드를 정의하는 함수형 인터페이스
4. test 메서드는 Apple을 받아서 boolean을 반환하는 함수 디스크립터를 묘사
5. filter 메서드로 전달된 인수는 요구사항을 만족해야함.

자바 컴파일러는 람다 표현식이 사용된 컨텍스트를 이용해서 람다 표현식과 관련된 함수형 인터페이스를 추론함.
즉, 함수 디스크립터를 알 수 있으므로, 컴파일러는 람다의 시그니처도 추론이 가능하다.
따라서 람다 문법에서 이를 생략할 수 있다.

```java
Comparator<Apple> c = (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());
Comparator<Apple> c = (a1, a2) -> a1.getWeight().compareTo(a2.getWeight());
```

### 지역 변수 사용

지금까지의 람다 표현식은 인수를 자신의 바디 안에서만 사용했지만, 람다 표현식에는 자유 변수를 활용할 수 있다.
이를 람다 캡처링이라고 한다.
하지만 이를 위해서는 지역 변수는 명시적으로 final로 선언되어 있거나 실질적으로 final로 선언된 변수와
똑같이 사용되어야 한다.

예를 들어서 다음 예제는 값을 두 번 할당하므로 컴파일할 수 없다

```java
int number = 1234;
Runnable r = () -> System.out.println(number);
number =4321;
```

이런 제약이 있는 이유를 알아보자
내부적으로 인스턴스 변수와 지역 변수는 태생부터가 다르다.
인스턴스 변수는 힙에 저장되는 반면, 지역 변수는 스택에 위치한다.

람다에서 지역 변수에 바로 접근할 수 있다는 가정하에 람다가 스레드에서 실행되면,
변수를 할당한 스레드가 사라져서 변수 할당이 해제되었는데도 람다를 실행하는 스레드에서는
해당 변수에 접근하려고 할 수 있다.

따라서 원래 변수에 접근을 허용하는 것이 아닌 지역 변수 복사본을 제공한다. 따라서 복사본의 값이 바뀌지 않아야 하므로
지역 변수에는 한 번만 값을 할당해야한다는 제약이 생겼다.

즉, 이렇게 사용하지 않으면 람다가 보관한 값과 실제 값이 달라지는 문제가 발생할 수 있다.