# 책임 주도 설계

Chapter4에서 데이터 중심 설계가 어떤 문제점을 가지고 있는지 알아보았다. 이제는 데이터에서 행동으로 초점을 옮겨야 할 때이다. 즉, 책임을 먼저 정하고 그에 따르는 객체의
상태를 정해야 한다.

그러면 다음과 같은 질문이 자연스럽게 따라왔다.

- 그렇다면 책임은 어떻게 정해야 하는 걸까?
- 책임을 어떻게 객체에 할당할까?
- 어떻게 책임을 할당하는 것이 잘 할당한 것일까?

그에 해당하는 답을 바로 다음에서 주고 있다.

- 책임은 객체가 아닌 객체가 참여하는 협력에 적합해야 한다.
- 책임은 메시지 전송자에게 적합해야 한다.
- 메시지가 객체를 선택해야 한다.

기존에 객체지향의 사실과 오해를 읽으며 메시지가 객체를 선택해야 한다는 말이 정확히 어떤 것이지? 라는 의문이 많이 존재했다. 당시에는 “책임을 먼저 메서드로 만들고 그거에 대해서
객체를 만들어서 할당하라는 건가” 하는 긴가민가한 마음으로 이해를 했었던 것 같다.

또한 기존에는 이 클래스가 무엇을 하는거지? 라는 식의 생각을 많이 했었던 것 같다. 근데 여기서는 메시지를 전송해야 하는데 누구에게 전송해야하지?? 라고 생각하면 메시지 기반
설계를 할 수 있다는 점에서 적잖이 놀랐다.

이 문구에 대해서 곱씹다 보니 의미에 대해서 조금 이해가 갈 것 같았다. 예전에는 일단 객체들을 만들고 어떻게 협력시키지? 라는 관점으로 바라봤던 것 같다. 하지만 올바르게 메시지
관점에서 생각을 해보니 메시지 송신자는 수신자에 대해서 아무것도 모르지 않아도 된다는 엄청난 장점이 있었다.

그냥 단순히 메시지를 전송하기만 하면 된다. 그러한 점에서 캡슐화를 극대로 끌어올릴 수 있고, 이는 곧 응집도를 높이고 결합도를 낮추는 것이 아닐까 싶었다.

# GRASP 패턴

GRASP는 General Responsibility Assignment Software Pattern 의 약자로 객체에게 책임을 할당할 때 지침으로 삼을 수 있는 원칙의 집합을
패턴으로 정리한 것이다.

이제 설계를 진행하는데, 설계를 도메인 개념에서 출발해서 진행하는 것이 좋다. 도메인 모델을 기반으로 책임을 할당하면 코드에서도 도메인 모델을 투영할 수 있고, 이는 곧 사람들이
생각하는 소프트웨어와 코드로 실제 구동하는 소프트웨어의 차이를 줄여줄 수 있다.

하지만 도메인 모델을 만드는데 너무 많은 시간을 들여서는 안 된다. 빠르게 설계와 구현을 진행하는 것이 좋다고 한다. 나는 왜 도메인 모델을 만드는데 많은 시간을 들이지 말라는건지
이해가 되지 않았다. 도메인 모델이 코드에 반영된다면 응당 당연히 도메인모델을 꼼꼼하게 만드는 것이 이득이 아닌가 싶었다.

하지만, 책에서는 도메인 모델은 하나가 아니고, 도메인 모델의 포함된 개념과 관계는 구현의 기반이 된다. 또한, 역으로 코드가 도메인 구조를 바꾸기도 한다고 한다.

책에 함부로 쓰여진 구절이 없는 것 같아 하나하나를 소화하면서 읽는 맛이 있는 것 같다. 객체지향의 사실과 오해로부터 학습한 어렴풋한 구절들이 오브젝트에서 구체화되며 매끄럽게
연결되는게 참 감탄스러울 정도이다. 앞으로는 문장에서 숨겨진 것 그리고 당연한 명제들에 “왜” 라는 생각으로 깊게 파고 들어가서 내부에 숨겨진 뜻을 발굴해 내고 싶다는 생각을
한다.

# 그러면 어떻게 책임을 할당하나요?

가장 간단한 방법은 객체는 자율적이어야 하므로 책임을 수행할 정보를 알고 있는 객체에게 책임을 할당하면 된다. 이를 INFORMATION EXPERT 패턴이라고 한다.

하지만 책임을 수행하는 객체는 정보를 알고만 있으면 되지, 저장할 필요는 없다. 객체는 해당 정보를 제공할 수 있는 다른 객체를 알고 있을수도 있다.
즉 직접 데이터로 저장하는 것과 알고있는 것은 다르다.

하지만 설계는 트레이드 오프 활동이다.

따라서 진행하고 있는 설계에서 여러 가지를 고려해 볼 수 있다.

```
Screening → Movie → DiscountCondtion
```

의 패턴도 가능하고 아래와 같은 패턴도 가능하다.

```
Screening
├─ Movie
└─ DiscountCondition
```

그렇다면 무엇이 더 좋은지에 관한 판단 기준이 있어야 하는데, GRASP 패턴에 의해서는 다음의 두 가지 관점에서 평가한다.

- LOW COUPLING (낮은 결합도)
    - 설계의 전체적인 결합도가 낮게 유지되도록 책임을 할당하라.

  DiscountCondition에게 책임을 할당하는 과정을 되돌아보자. DiscountCondition은 Movie와 협력하는 것이 Screening과 협력하는 것보다 좋다.
  왜냐하면 Movie와 DiscountCondition은 이미 도메인 상에서 결합됐기 때문에 새로운 의존성을 추가할 필요가 없다.

- HIGH COHESION (높은 응집도)
    - 높은 응집도를 유지할 수 있게 책임을 할당하라

      Screening의 책임은 예매를 생성해 내는 것이다. 만일 Screening과 DiscountCondition이 협력한다면 Screening이 영화 요금 계산과 관련된
      책임을 일부 떠안아야 하며 이는 곧 Screening이 DiscountCondition이 할인 여부를 판단하며 Movie가 이 정보를 필요로 함도 알아야 한다.

> 책임을 할당하고 코드를 작성하는 순간마다 LOW COUPLING과 HIGH COHESION의 관점에서 전체적인 설계 품질을 검토하면 유연한 설계가 가능해진다.

# 객체 생성 책임은 창조자에게

다시 원점으로 돌아가서 클라이언트가 영화 서비스에 원하는 것은 아주 단순하다. 상영에 관한 Reservation이라는 객체를 생성하는 것이다. 즉, 어떤 객체는
Reservation 인스턴스를 생성해야 하는 책임이 있다는 것이다.

이러한 경우 다음의 CREATOR 패턴을 이용하면 된다.

다음의 조건들을 최대한 많이 만족하는 B가 CREATOR가 된다.

- B가 A객체를 포함하거나 참조한다.
- B가 A객체를 기록한다.
- B가 A객체를 긴밀하게 사용한다.
- B가 A를 초기화 하는데 필요한 데이터를 가지고 있다.

직접 한 번 Reservation을 누가 만들어야 하는지를 생각해 보았다.

> 우선 Reservation은 예약 정보가 담겨있어야 함.
> 영화 정보, 가격, 상영 시간에 관한 정보가 들어있어야 함.

이 것들은 모두 상영 정보로 Screening이 알고 있음.
또한 Screening은 Movie에 대해서 알고 있기 때문에 Reservation에 미처 생각하지 못했던 것이나
확장 가능한 부분에 대해서 커버가 가능할 것 같음.

또한 Screening은 상영 정보를 전달해주는 책임을 맡고 있기 때문에
Screening이 Reservation을 만드는 CREATOR가 되어야 할 것 같다.

여기서 인상 깊었던 것은 이렇게 직접 설계 과정을 진행해 보면서, 나는 개인적으로 완벽한 설계도가 중요하다고 생각했는데 사실 가장 새로웠던 것은 내가 설계한 일련의 책임들과
협력들이
제대로 동작하는가를 중간에 코드로 직접 검증해 보고 실행해 보는 것이다.

앞으로도 직접 설계 과정에서 난해한 점이나 어려운 점이 있다면 설계에 이어서 코드로 직접 구현해 보며 검증을 해나가는 습관을 들여야겠다.

언제나 `“완벽한 설계는 없다”` 라는 관점으로 설계를, 코드를 기반으로 검증하고, 계속 해서 애자일하게 변경이 수용 가능하도록 설계도 리펙토링이 이루어질 수 있다는 관점이
새로웠다.

# 구현을 통해서 검증하자

그러면 지금까지의 설계를 모두 코드를 통해서 올바르게 설계했는지를 한 번 확인 해보자.

지금까지 설계한 구조는 다음과 같다.

```
Screening -> Movie -> DiscountCondtion
	|
	-> Reservation
```

우선 기존에 설계했던 것처럼 시스템의 책임을 기반으로 시작해서 설계했던 대로 하나씩 구현해 나가면 된다.

다음은 간단한 예시이다.

```java
public class Screening {

    private Movie movie;
    private int sequence;
    private LocalDate whenScreened;

    public Reservation reserve(Customer customer, int audienceCount) {
        return new Reservation(customer, this, calculateFee(audienceCount), audienceCount);
    }

    public Money calculateFee(int audienceCount) {
        return movie.calculateFee(this).times(audienceCount);
    }
}
```

이렇게 시스템의 책임을 기반으로 시작해서 책임을 수행하는 것에 필요한 인스턴스 변수들을 결정해야 하는데, Screening은 상영 시간과 상영 순번을 가지며, 영화에게 계산을
해달라고 해야 하니 Movie에 대해서도 알고 있어야 한다.

또한 여기서 주의할 점은 메서드의 시그니처가 `calculateFee(int audienceCount)` 라는 점이다. 이는 수신자가 아닌 송신자의 관점에서 기술된 것이다. 즉,
Movie의 내부 구현과는 전혀 상관없이 메시지를 정한 것이다.

이렇게 했을 경우 Movie와 Screening 간의 관계에서 유일한 연결은 메시지 하나뿐이다. 따라서 메시지 자체가 수정되지 않는 이상 Movie 내부의 어떠한 수정이 있다고
해도 Screening은 수정할 필요가 없다.

이제 추가로 Movie와 DiscountCondition까지 이와 동일한 방식으로 구현을 마쳤다.

# 근데 구현을 해보니까 문제가 있다

DiscountCondition을 구현을 마쳤지만, 다음의 문제가 있다.

> 1. 새로운 할인 조건 추가 시 if-else문을 수정해야 한다.
> 2. 순번조건을 판단하는데 필요한 데이터가 변경되면 sequence 속성 역시 변경해야 한다.
> 3. isSatisfiedPeriod메서드 내부 구현을 수정해야 할 여지가 있다. (기간조건의 변경)

이런 일이 일어나는 이유는 DiscountCondition이 낮은 응집도를 가지고 있기 때문인데, 이를 해결하기 위해서는 변경의 이유에 따라 클래스를 분리해야 한다. 여기서 변경의
이유에 따라서 클래스를 분리하라는 말이 무엇인가를 고민해 봤는데, 하나의 클래스가 여러 개의 이유로 변경이 가능하다는 것을 의미하는 것 같았다.

> 즉, 하나의 클래스가 여러 가지의 이유로 변경이 가능하다면, 이 클래스는 여러 개의 책임을 동시에 짊어진 것이며, 낮은 응집도로 구성되어 있음을 의미한다.

DiscountCondition의 두 메서드는 서로 다른 이유로 변경된다. 즉, 순번과 기간에 따라서 구현이 변경되어진다. 이러한 변경의 이유를 파악하는 방법은 두 가지이다. 이를
통해서 응집도를 체크할 수 있다.

1. 인스턴스 변수가 초기화되는 시점

   클래스의 속성이 서로 다른 시점에 초기화되거나 일부만 초기화된다면 응집도가 낮다. 따라서 함께 초기화가 되는 것을 기준으로 분리해야 한다.

2. 메서드들이 인스턴스 변수를 사용하는 방식

   모든 메서드가 객체의 모든 속성을 사용한다면 클래스의 응집도는 높다.

즉, isSatisfiedBySequence는 오직 sequence만 사용하며, isSatisfiedByPeriod는 dayOfWeek, startTime, endTiem만을
사용한다. 즉, 응집도를 높이기 위해서는 속성 그룹과 그에 해당하는 메서드 그룹을 기준으로 코드를 분리해야 한다.

즉, 다음의 세 가지로 응집도를 조사할 수 있다.

> - 클래스가 하나 이상의 이유로 변경되는 경우 응집도가 낮은 것
> - 초기화의 시점에 따라 서로 다른 속성을 초기화한다면 응집도가 낮은 것
> - 메서드 그룹이 속성 그룹을 사용하는지의 여부로 나뉘면 응집도가 낮은 것

그렇다면 간단한 해결 방법은 DiscountCondition을 두 가지의 Condition으로 분할하는 것이다. 그러면 앞에서 찾은 문제들이 모두 해결된다. 하지만 이렇게 분할을
진행했어도 문제가 존재한다. Movie 객체는 SequenceCondition과 PeriodCondition 두 개의 객체 모두와 협력을 해야한다.

하지만 Movie의 입장에서는 SequenceCondition이나 PeriodCondition이나 차이가 없다. 둘 모두 할인 여부에 대해서 판단을 해주는 역할을 가지고 있다.
따라서 역할을 통해서 객체의 구체적인 타입을 추상화할 수 있다. 구현의 공유를 할 필요 없이 역할을 대체하는 객체의 책임만 정의할 때는 interface를 사용한다.

> 구현의 공유가 필요하다면 당연히 추상클래스를 사용하면 될 것이다. 하나의 역할에서 공통된 구현의 공유가 필요한지의 여부에 따라서 추상클래스와 인터페이스를 적절히 운용하면 될 것
> 같다.


객체의 타입에 따라서 변하는 행동이 있다면 타입을 분리하고 변화하는 행동을 각 타입의 책임으로 할당한다. 이를 GRASP패턴에서는 POLYMORPHISM 패턴이라고 한다.

이렇게 다형성을 이용해서 구축하면 새로운 정책이 추가되더라도 Movie 에 대해서는 일절 수정 하나 없이 그냥 단순하게 NoneCondition 이나 새로운 무언가를 추가하기만
하면
된다.

이를 PROTECTED VARIATIONS 패턴이라고 한다.

# Movie 역시 마찬가지로 리펙토링 하자.

Movie 역시 내부에서 두 개의 타입을 하나의 클래스에서 처리하고 있기 때문에 응집도가 낮다. 이 또한 POLIMORPHISM 패턴을 통해서 타입별로 분리시킨다.

Movie는 구현을 공유할 필요가 있으니 추상클래스로 만들고, 이를 상속받는 AmoundDiscountMovie, PercentDiscountMovie,
NoneDiscountMovie를 만드는 것이다.

하지만 영화와 설정된 할인 정책이 실행 중에 변경되어야 하는 경우 상속을 하고 있기에 새로운 인스턴스를 만들어서 데이터를 복제해야 한다. 하지만 이러한 경우는 번거롭고 오류가
발생하기 쉽다. 따라서 복잡성이 높아져도 할인 정책의 변경을 쉽게 수용할 수 있게 만드는 것이 좋다.

즉, DiscountPolicy를 만들고 이를 Movie와 결합시키면 된다. 이렇게 유연성은 의존성 관리 차원의 문제이다. 의존성의 정도가 유연성의 정도를 결정한다.

# 책임 주도 설계의 대안

책임 주도 설계를 하기 위해서는 부단한 노력과 시간이 필요하다. 충분한 경험과 학습이 필요하다. 그러나 경험을 쌓은 설계자도 어려움을 느끼고는 한다.

그래서 일단 돌아가는 코드를 만들고 리펙토링을 하라고 제안하고 있다.

그래서 다음의 단계를 따라서 리펙토링 하라고 한다.

1. 메서드를 응집도 있는 수준으로 분해한다.
2. 메서드를 사용하는 데이터가 있는 곳으로 이동시키자.
3. POLYMORPHISM 패턴과 PROTECTED VARIATIONS 패턴을 적용하자.

# 소감

조금의 가려움이 해소되는 챕터였다. 구체적으로 내가 설계 과정에서 어떻게 하면 좋을지를 확실하게 배울 수 있었다. 어찌 보면 설계 단게와 구현 단계는 두 개로 분리된 과정이 아니라
서로 상호작용하며 좋은 설계와 좋은 코드로 나아가는 것 같다고 생각했다.

가장 인상 깊었던 것은 도메인 모델 자체가 코드에 의해서도 수정될 수 있다는 것이었다. 기존의 생각으로는 완벽한 설계를 해야만 한다고 생각했지만, 이제 이런 강박을 조금 내려놓고
직접 구현을 해보면서 “이러이러한 부분에 문제가 있구나?” 를 출발로 계속해서 코드를 수정하면서 조금 더 나은 설계와 구현으로 나아갈 수 있을 것 같았다. 마치 결합도와 응집도를
기준으로 계속해서 애자일하게 개발해 나가는 하나의 프로세스 같았다.

또한 DiscountCondition이나 Movie와 관련해서 구현하면서 발생한 문제들을 POLYMORPHISM 패턴과 PROTECTED VARIATIONS 패턴을 기반으로
변경의 파급효과를 최소한으로 줄이는 설계를 할 수 있도록 배운 것 같아서 매우 기쁠 따름이다.

근데 저자의 사고를 따라 구현을 진행해 보았으나, 직접 구현해 보면서 배워야 할 필요가 있을 것 같다. 아직 여전히 어떻게 해야 하는지에 관해서 부족함이 존재하는 것 같다.
설계부터
구현까지 책임 주도 설계를 꾸준히 연습해야 하지 않을까 싶다.

이제 구현 과제를 직접 해보면서 공부해야 할 것 같다!