# 협력과 메시지

객체지향을 잘 하기 위해서는 객체를 지향해야 한다. 중요한 것은 책임이 객체가 수신할 수 있는 메시지의 기반이 된다. 객체가 수신하는 메시지들이 객체의 퍼블릭 인터페이스를
구성한다.

메시지를 수신하면 수신자의 타입에 따라서 어떤 코드가 실행되느냐에 따라 다르다. DiscountCondition이 있을 때 금액할인과 비율할인이 있는 것처럼 말이다. 따라서 실제로
실행되는 프로시저 또는 함수를 메서드라고 부른다. 즉, 이는 컴파일 시점과 실행 시점의 의미가 달라질 수 있다는 것이다.

그리고 객체는 퍼블릭 인터페이스만을 통해서 협력이 가능하다. 프로그래밍 언어의 관점에서 퍼블릭 인터페이스에 포함된 메시지를 오퍼레이션이라고 한다고 한다. 흔히 오퍼레이션을 말할
때는 구현은 제외하고 메시지와 관련된 시그니처만을 가리키는 경우가 다수이다. 따라서 메서드 호출보다 오퍼레이션 호출이 더 적절하다.

흔히 함수, 메서드, 메시지, 프로시져, 오퍼레이션 용어들을 계속해서 혼용해서 사용했었는데, 이제 정확하게 갈피가 잡히는 것 같다. 단어의 정의를 명확하게 이해하고 사용하는 것이
좋다고 생각한다. 개발자들끼리 소통을 위해서는 엄밀한 단어를 사용하는 것이 좋을 것 같다는 생각을 종종 한다.

# 인터페이스와 설계 품질

퍼블릭 인터페이스의 품질에 영향을 미치는 원칙과 기법에 대해서 살펴보도록 한다. 무언가 원칙과 기법, 방법론들이 점점 많아지는 것 같아서 한 번 정리가 필요할 것 같다. 이 챕터가
끝나고 나서 한 번 Chapter1 부터 지금까지 한 번 싹 훑어서 헷갈리거나 어려운 부분들을 한 번 정리하고자 한다.

### 디미터 법칙 (Law of Demeter)

간단하게 요약하자면 객체 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하는 것. 간단하게는 오직 하나의 도트만 사용하라는 말로 요약되기도 한다.

클래스 내부의 메서드가 다음 조건을 만족하는 인스턴스에만 메시지를 전송하도록 프로그래밍 해야한다.

<aside>

- this 객체
- 메서드의 매개변수
- this의 속성
- this의 속성인 컬렉션의 요소
- 메서드 내에서 생성된 지역 객체

</aside>

그러면 이렇게 디미터 법칙을 준수하면 어떤 이점이 있을까?

바로 shy code를 작성할 수 있다고 한다. 이는 불필요한 어떤 것도 다른 객체에게 보여주지 않으며, 다른 객체의 구현에 의존하지 않는 코드를 말한다.

즉 다음과 같은 코드를 사용하면 안 된다.
`audience.getBag().hasInvitation()`

이런 코드를 train wreck (기차 충돌) 이라고 하는데, 이는 내부 구현이 외부로 노출됐을 때 나타나는 현상이다.

메시지 전송자는 메시지 수신자의 내부 정보를 자세히 알게 된다.

Theator 객체가 Audience 객체가 Bag을 가지고 있다는 것을 알게 되는 것처럼 말이다.

### 묻지 말고 시켜라 (Tell, Don’t Ask)

메시지 전송자는 수신자의 상태를 기반으로 결정을 내리고 수신자의 상태를 바꿔서는 안 된다. 객체ㅢ 외부에서 해당 객체의 상태를 기반으로 결정을 내리는 것은 객체의 캡슐화를
위반한다.

객체지향의 기본은 변경의 확률이 높은 정보와 행동을 하나의 단위로 통합해서 응집도를 높여야 한다. 묻지말고 시켜라를 따르면 객체의 정보를 이용하는 행동을 객체의 내부에 위치시키기
때문에 정보와 행동을 동일한 클래스 안에 두게된다.

<aside>

내부의 상태를 묻는 오퍼레이션을 인터페이스에 포함하고 있다면 더 나은 방법이 없는지를 고민해 봐야한다. 내부 상태를 이용해 어떤 결정을 내리는 로직이 객체 외부에 존재하나? →
그렇다면 객체가 책임져야 하는 행동이 외부로 누수된 것이다.

</aside>

### 의도를 들어내는 인터페이스

메서드를 명명하는 방법이 있는데

1. 메서드가 작업을 어떻게 수행하는지를 나타내도록 이름 지어야 함.
2. 어떻게가 아니라 무엇을 하는지 드러내야 한다.

isSatisfiedByPeriod() → isSatisfiedBy()

가장 간단한 방법은 DiscountCondition이라는 인터페이스를 정의하고 그 안에 isSatisfiedBy() 오퍼레이션을 정의하는 것.

그러면 어떻게 하면 메서드에 의도를 드러내는 이름을 지을 수 있나요?

<aside>

매우 다른 두 번째 구현을 상상하고 해당 메서드에 동일한 이름을 붙인다고 상상하면,

그 순간 가장 추상적인 이름을 메서드에 붙이게 될 것이다.

</aside>

### 명령 쿼리 분리 원칙

프로시저는 정해진 절차에 따라 내부의 상태를 변경하는 루틴의 한 종류이며, 함수는 어떤 절차에 따라 필요한 값을 계산해서 반환하는 루틴의 한 종류이다.

- 프로시저는 side effect를 발생시킬 수 있지만, 값을 반환할 수 없다.
- 함수는 값을 반환할 수 있지만 side effect를 발생시킬 수 없다.

따라서 개념적으로는 명령은 프로시저랑 동일하고 쿼리는 함수와 동일하다.

<aside>

이 원칙의 핵심은 오퍼레이션은 side effect를 발생시키는 명령이거나, side effect를 발생시키지 않는 쿼리 중 하나여야 한다는 것이다.

- 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.
- 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.

</aside>

명령과 쿼리가 섞이면 실행 결과를 예측하기가 어려워질 수 있다. isSatisfied 메서드처럼 겉으로 보기에는 쿼리처럼 보이지만, 내부에 부수효과를 가진다면 예측하고 이해하기가
어려워서 버그를 양산해낼 수 있다. 따라서 명령과 쿼리를 명확히 분리하는 것이 좋다.

# 원칙의 함정

소프트웨어 설계에 법칙이란 존재하지 않는다. 법칙에는 예외가 없지만 원칙에는 예외가 넘쳐난다.

<aside>

가장 중요한 것은 설계는 트레이드 오프의 산물이라는 것이다. 원칙이 현재 상황에 부적합하다면 원칙을 무시하자. 원칙을 아는 것보다 중요한 것은 언제 원칙이 중요하고 유용하지
않은지를 판단할 수 있는 능력을 길러야 한다.

</aside>

예를 들어서 특정 로직을 특정 클래스에서 처리할 때 내부 상태를 가져와서 사용할 때 캡슐화를 위반한 것처럼 생각해보자고 하자. 그래서 이를 해결하기 위해 로직을 다른 객체로 옮겨서
한다고 하면, 문제가 발생할 수 있다.

예를 들어서 Screening으로 isDiscountable()을 만들어서 할인 여부를 처리한다고 하면, screening은 기간에 따른 할인 조건을 떠안는다. 이는
Screening이 처리할 본질적인 책임이 아니다. Screening의 주된 책임은 영화를 예매하는 것이다. Screening이 직접 할인 조건을 판단하게 된다면 응집도가
낮아진다.

# 그래서 어떻게 하는데??

책임 주도 설계를 해서, 메시지가 객체를 선택하도록 하자. 그리고 이 모든 과정에는 책임이 위치한다. 이런다면 협력에 적합한 메시지를 결정할 확률이 높아진다.

# 소감문

여러 원칙들에 대해서 공부해봐서 좋았다. 근데 여전히 어려운 것은 어떨 때 사용해야 하는지 감이 잘 안 온다는 것이다. 예제를 봐도 여전히 직접 만들어보고 고민해본 것이 아니라서
잘 감이 오지를 않는다. 이거는 경험에 의해서 습득해야 하지 않을까…?

결국 중요한 것은 코드를 많이 짜봐야하는 것이 아닐까? → 우아한 테크코스를 하면서 오브젝트의 내용을 본격적으로 적용해보고 활용해보고 좋은 객체지향 코드를 짜보면 더 좋을 것
같다. 아직 코드를 보고 잘 모르겠다는 것은 아직 코드를 많이 안 써봤다는 뜻 아닐까?

오브젝트를 하면서 배우는 것도 많은데, 그만큼 벽을 많이 느끼는 것 같다. 최근 들어서 생각하는 건 내가 머릿속에 넣는 것만큼 실제로 코드로 꺼내지를 않는 것 같다는 생각이 많이
든다. 현재 코드를 짜는 것은 코딩테스트를 제외하면 다른 아무것도 하지 않는 것을 생각하고 반성을 하게 된다.

그래도 이번 챕터에서 디미터 법칙에 대해서 잘 알 수 있어서 좋았다. 계속해서 코드를 작성해보면 게터를 사용하고 .(도트) 이 길어지고 코드가 안 예뻐지는 경우가 매우 많았었는데,
이제는 확실하게 행동과 정보를 동시에 객체 내부에서 관리해서 응집도를 끌어올릴 수 있다는 것을 알 수 있어서 이제 더 코드를 잘 짤 수 있지 않을까?

그리고 신기한 것은 쿼리랑 명령을 구분해서 처리한다는 게 제일 놀랍다. 저렇게 하면 코드의 퀄리티를 더 끌어올릴 수 있다는 게 참 신기했다.