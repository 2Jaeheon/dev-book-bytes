# 어떤 설계를 해야 할까?

객체지향 세계에서는 상태는 구현이고, 불안정하기 때문에 좋은 설계를 만들어낼 수 없다. 따라서 객체를 일종의 데이터와 행동을 가지는 하나의 자율적인 존재로서 바라보고, 이러한
객체들이
협력이라는 공동체 내에서 자율적으로 활동할 수 있도록 적절히 책임을 분배하는 것이 가장 중요하다.

# 그렇다면 왜 데이터 위주 설계는 문제가 될까?

데이터 중심 설계는 다음과 같이 이루어진다.

> 객체에 어떤 데이터가 포함되어야하지?


따라서 기존의 책임 할당에서는 Movie가 책임져야 하는 것은 `영화 금액을 계산하기` 이 하나였으나, 데이터 중심 설계에서는 데이터를 기반으로 하기 때문에 캡슐화가 제대로
이루어지지 않는다.

코드가 긴 관계로 다른 것들은 모두 생략하고 Movie 객체에 대해서만 기술하고 넘어가도록 한다. 다음은 Movie 객체를 만들 때의 사고 과정을 나타낸 것이다.

```
나는 Movie 객체를 만들어야 해.
그렇다면 Movie 객체에는 어떤 데이터가 필요할까?
영화의 타이틀(제목)이 필요할 거야.
영화의 요금도 필요하겠지.
상영 시간도 필요할 거야.
그리고 영화는 할인될 수 있으니까 할인 조건도 필요하겠지. 근데 할인 조건은 여러 개가 될 수 있으니까 List를 쓰자
그리고 영화의 타입에 따라 비율할인과 금액할인 또는 할인 미적용으로 나누어지니까
영화의 타입을 저장하는 것이 필요할 거야.
또 영화 타입별로 할인이 비율 또는 금액이니까 비율에 관한 정보를 저장해야 하고
금액에 관한 정보를 따로 저장해야 할 거야```

```java
public class Movie {

    private String title;
    private Duration runningTime;
    private Money fee;
    private List<DiscountCondition> discountConditions
    private MovieType movieType;
    private Money discountAmount;
    private Double discountPercent;
}
```

데이터 중심의 설계는 위와 같이 이루어지게 된다. 이렇게 구현된 것을 chapter2의 책임 위주의 설계와 비교해 보았을 때 가장 큰 차이점은 `DiscountPolicy`가 아닌
`Movie`라는 객체가 dicount 정책에 관한 직접적인 인스턴스를 가지게 된다는 것이다.

여기서 발생하는 가장 큰 문제는 객체가 자율적이지 못하고 마치 DTO처럼 동작하게 된다는 것이다. 또한, 그리고 다른 Screening이라는 객체가 존재할 때 할인 금액을 계산하기
위해서는 Movie 내부의 속성들을 모두 알아야 금액을 계산할 수 있게 된다. 즉 MovieType을 알고, discountAmount를 알아야만 할인 금액을 알 수 있는데, 이는
캡슐화가 위반된 사례이다.

또한, 할인 정책이 삭제되거나 추가되거나 수정되는 경우 Screening의 코드가 반드시 수정되어야만 한다. 왜냐하면 강하게 결합되어 있기 때문이다. 이러한 사례를 결합도가 높다고
말한다.

할인과 관련된 데이터는 Movie에 있으나, 할인을 계산하고 사용하는 로직은 Screening에 흩어져 있을 것이기 때문에 이는 하나의 관심사가 여러 개로 분산되어 있다고 볼 수
있다. 이를 응집도가 낮다고 표현한다.

따라서 이는 변화에 매우 취약한 시스템이 되며, 하나를 수정할 때 여러 곳을 수정해야하는 비용이 발생한다. 이에 더해서 객체지향의 원칙중 하나인 OCP 원칙에도 어긋나는 것을 볼
수 있다. 항상 확장에는 열려있고, 수정에는 닫혀 있어야 한다.

> 물론 책의 예제에서는 ReservationAgency를 만들어서 서비스계층으로 사용하였고, 객체들을 일종의 DTO처럼 사용하여 구성되어 있었으나, 여기서는 이해를 위해
> Screening이 금액에 관한 계산을 진행하였다고 매우 단순화하여 설명하였음.

# 캡슐화, 응집도, 결합도

개발하면서 응집도와 결합도를 정말 많이 들어본 것 같다. 하지만, 항상 공부하고 나면 “응집도가 객체끼리 연결된건가?” 라는 생각을 할 정도로 까먹기 일쑤였다. 이제는 객사오와
오브젝트를 통해서 확실히 정리하고 까먹지 않을 것 같다.

- 결합도: 의존성의 정도
- 응집도: 모듈에 포함된 내부 요소들이 연결되어 있는 정도

우리는 이제 변경에 안전한 시스템을 설계해야하기 때문에 이를 변경의 관점에서 생각해 보도록 한다.

- 결합도: 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도
- 응집도: 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도

따라서 결합도는 낮으면 낮을수록 좋고, 응집도는 높으면 높을수록 좋다.

그렇다면 응집도와 결합도를 어떻게 관리할 수 있을까?? 정답은 캡슐화다. 캡슐화의 정도가 응집도와 결합도에 큰 영향을 미치게 된다. 따라서 응집도와 결합도를 걱정하기보다 캡슐화를
얼마나 잘할지를 걱정하는 것이 좋아 보인다.

# 캡슐화를 잘하자

우리는 캡슐화를 잘해야 함을 깨달을 수 있었다. 객체는 자신의 속성(데이터)을 절대로 외부에 노출하면 안 되고 캡슐화해야 한다. 또한, 객체는 스스로의 상태를 책임져야 하며
외부에서는 인터페이스에 정의된 메서드를 통해서만 상태에 접근할 수 있어야 한다.

일반적으로 getter와 setter를 사용해서 만들어진 하나의 A객체는 외부의 B객체에 의해서 호출된다. 이는 곧 A객체가 사용되는 대부분의 공간에서 중복되는 코드들이 발생할 수
있음을 나타낸다.

그리고 변경에 취약해지는 결과를 낳을 수 있다. 변수명이 바뀐다면 모든 것들을 다 바꾸어야 하고, 기존의 모든 코드에 영향을 미치게 된다. 예를 들어서
getCalculatedMoney() 라는 메서드가 있다고 칠 때 getCalculatedFee()로 바꿔버리면 코드베이스를 모두 뒤져서 다 수정해야 할 것이다.

따라서 이를 막기 위해서는 무조건 캡슐화해야만 한다.

그러면 이제 다음의 질문이 따라 나올 수밖에 없다.

> 어떻게 캡슐화해야 하는데?

# 캡슐화하는 방법

캡슐화를 하는 방법은 객체가 스스로의 상태를 처리할 수 있도록 해주면 된다.

즉, 하나의 객체가 어떤 데이터를 포함하는지와, 어떤 오퍼레이션을 수행해야 하는지를 동시에 고려해서 설계하면 된다.

위에서 들었던 Movie 예시를 다시 해보도록 한다.

```
Movie 가 가져야 하는 값들은 이미 이전의 정의를 했음.

그렇다면 Movie가 어떤 오퍼레이션을 수행해야 하지??

1. 영화에 관한 할인이 가능한지를 체크해 줘야 함.
2. 영화 요금에 대해서 계산해 줘야 함.
```

이렇게 설정하였을 때, Movie의 내에는 여러가지의 메서드들이 생기게 된다.

```java
public class Movie {

    public Money calculateAmountDiscountedFee() {
        if (movieType != MovieType.AMOUNT_DISCOUNT) {
            throw new IllegalArgumentException();
        }

        return fee.minus(discountAmount);
    }
	... // 중략

    public boolean isDiscountable(LocalDateTiem whenScreened, int sequence) {
		...
    }
}
```

이제 Screening은 Movie가 정책이 지원되는 경우에 Movie에게 isDiscountable() 메서드를 호출해서 할인 여부를 확인해서 movie의 메서드를 호출해서
요금을 계산하는 방식으로 구축된다.

# 그래도 부족하다

하지만 문제는 여전하다.

DiscountCondition의 isDiscountable() 메서드의 시그니처를 보면 DayOfWeek, LocalTime 등을 파라미터로 받는 것을 알 수 있다. 이는
인스턴스 변수로 내부 데이터가 있다는 것을 외부에 노출 중인 것과 다름이 없다.

또한, DiscountCondition의 속성을 변경한다면 이에 따라 클라이언트도 모두 수정해야할 것이다.

그렇다면 캡슐화는 대체 뭘까. 저자가 객사오에서 한 말을 빌리자면, 변할 수 있는 것을 모두 감추는 것이라고 한다. 지금 내부 속성을 감추는 것은 캡슐화의 일부인 데이터 캡슐화라고
한다.

그렇다면 isDiscountable에는 뭘 넘겨줘야할까?

구체적인 값을 넘기는 것은 캡슐화를 깨고 결합도를 높이기 때문에 context를 보내야 한다. 즉, isDiscountable이 수행하는 것(할인이 가능한지의 여부를 판단)을 위해
필요한 정보인 screening을 보내주어야 한다.

처음에는 screening을 보내지 않고 인자로 데이터를 확실히 넘겨주는 것이 좋다고 생각했는데, 캡슐화와 유지보수의 관점에서 생각하니 그게 옳지 않다는 것을 느끼게 됐다.

이렇게 screening만을 전달하게 되면, DiscountCondition는 할인 조건을 판단하기 위해서 요청을 받아서 실행했는데, 스스로 처리가 불가능했다. 따라서
Movie에게 isDiscountable()을 보냈을거고, 영화는 또한 이를 처리하기 위해서 내부에서 스스로 책임을 질 것이다. 근데 그 와중에 조건을 확인하기 위한 데이터가 없기
때문에 Screening에게 또한 요청을 보낸다. 그러면 조건에 맞춰 Screening은 알아서 계산을 해서 다시 DiscountCondition은 원하는 정보를 얻어낼 수 있게
된다.

- **Client → `Movie`**: "영화 요금 계산해 줘."
- **`Movie` → `DiscountPolicy`**: "할인 금액이 얼마인지 계산해 줘."
- **`DiscountPolicy` → `DiscountCondition`**: "지금 할인 가능한 조건이야?"
- **`DiscountCondition` → `Screening`**: "네가 가진 상영 정보로 판단했을 때, 이 조건에 부합하니?"

원래 기존에는 DiscountCondition이 Screening을 직접 getter 같은 걸로 까보는 거면 그냥 인자를 보내는 거랑 별 차이가 없을 거 같다고 생각했지만, 결국
screening까지 책임이 전파가 되고 하나의 협력 구조에서 객체들이 자율적으로 처리하도록 처리하는 방식이라는 걸 깨닫게 됐다.

# 그러니 책임 주도 설계를 하자.

이런 식으로 데이터 중심 설계는 캡슐화가 안 되고 이에 따라서 응집도가 낮고 결합도는 높은 좋지 않은 아키텍처가 만들어진다. 따라서 구현을 먼저 생각하는 것이 아닌 책임을 기반으로
객체의 외부를 기준으로 협력구조를 판별하고 책임을 적절히 분배한 다음에야 구현을 생각하는 것이 옳다.

# 왜? 모먼트

getter/setter를 쓰지 않아도 정책이 노출이 가능할까??

나의 답: Yes! → 왜냐하면 객체의 타입을 물어보고 if-else 문 같은 걸로 클라이언트에서 분기 처리를 하는 경우 결국 getter를 사용하는 것과 동일한 구조가 된다.
즉,
이렇게 진행되었을 때 내부 정책이 모두 클라이언트에게 노출되어서 캡슐화를 어기게 된다.

그래서 이를 해결하기 위해서는 interface 또는 abstract class 를 사용하여 책임을 위임하도록 해야 한다. 즉, Movie가 할인을 알려주는 것이 아닌, 할인 정책
객체가 스스로 게산이 가능하도록 책임을 전가 시켜줘야 한다. 그렇게 된다면 클라이언트는 가볍게 calculateFee() 하나로 깔끔하게 메시지를 보낼 수 있다.

또한, 메서드에 파라미터로 상세한 정보들을 제공해주는 것 역시 정책이 노출되는 것을 일으킨다. 따라서 개별 데이터를 제공하는 것이 아닌, 자율적인 객체를 넘겨서 객체가 스스로
처리할 수 있도록 하는 것이 바람직하다. 즉, 옆에 있는 사람이 뭘 못하고 있을 때 답을 알려주는 것이 아닌, 사람을 소개해 주는 것과 같은 이치다.

# 객체를 지향하자

지금까지 구현해 온 방식은 모두 Data 기반의 절차지향적인 코드였다는 것을 깨달았다. 지금껏 내가 객체지향스러운 코드를 짜고 싶다고 말하고, 줄곧 생각해 왔지만 그럼에도 불구하고
하지 못했던 것은 내가 계속해서 데이터 위주의 접근을 펼쳤기 때문이다. 늘 코드를 짜고 나면 파이프가 한쪽에서 터져서 막으면 다른 쪽이 터지는 것처럼 돌려서 터진 관을 막는 듯한
코드 퀄리티였다고 생각한다.

하지만 이제 왜 데이터 중심의 설계가 객체지향 패러다임에서 적합하지 않은지를 깨달았으며, 어떻게 해야 내부와 외부를 분리해 주는 캡슐화를 통해서 안정적인 설계를 만들어낼 수
있는지에
대해서 알 수 있어서 기쁘다. 처음에는 아니 그래서 이게 왜 데이터가 노출되는거지? 라고 생각을 했지만, 데이터를 다 제공해 주면서 함수의 시그니처에서 다 내부 구현체가 보인다면,
그것은 캡슐화에 실패했던 것이라는 걸 다시 상기하게 됐다.

객체지향의 사실과 오해에서 고객이 커피를 캐셔에게 시키고 캐셔는 바리스타에게 커피를 만들으라고 하며 커피 공화국에서 아침이 시작되지 않았는가. 기존의 나는 메서드에 파라미터로
데이터를 보내는 것과 객체를 보내는 것이 내부 데이터를 노출시키는 것은 똑같지 않나? 라고 생각을 했지만, 커피공화국을 다시 떠올려보니 객체를 넘기는 것은 일종의 판단을 다른
전문가에게 위임하는 것이라는 것을 깨달았다.

결과적으로 객체를 넘기는 것도 어쨋든 의존성을 지니는 것은 어쩔 수 없다. 하지만, 데이터를 넘기게 된다면 특정 행위에 대한 판단을 책임을 가지지 않은 객체가 수행해야하기 때문에
문제가 발생하는 것이다. 객체를 넘기는 것은 public interface에만 의존하는 것임을 다시 한번 깨달을 수 있었다.